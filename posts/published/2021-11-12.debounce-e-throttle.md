---
path: /debounce-e-throttle

title: Debounce e Throttle
subtitle: O que s√£o, para que servem e como funcionam essas t√©cnicas (ou padr√µes) parar adiar eventos
date: 2021-11-12
tags:
  - dev
  - js

banner:
  author: Kai Pilger
  href: https://unsplash.com/photos/1k3vsv7iIIc
  image: ./images/2021-11-12.debounce-e-throttle/banner.jpg
---

Quando estamos escrevendo nossa aplica√ß√£o e lidando com intera√ß√µes em tela, nem sempre queremos que alguma a√ß√£o aconte√ßa logo de imediato, assim que um evento √© disparado. Principalmente quando essa a√ß√£o envolve alguma requisi√ß√£o HTTP para um servi√ßo externo.

As t√©cnicas de `debounce` e `throttle` servem para adiar algum acontecimento dado um determinado tempo.

### Um caso de uso pr√°tico e bem comum

Um cen√°rio bem comum √© na busca de produtos dentro de um e-commerce.

Quando voc√™ entra em um site para comprar um produto, voc√™ vai interagir com alguma barra de busca para encontrar o que est√° pesquisando. Em muitos cen√°rios, dependendo da palavra ou dos trechos que voc√™ escreveu, algumas sugest√µes de busca aparecem. Bem comum, n√©?

O que t√° acontecendo nos bastidores dessa pesquisa com sugest√µes √© que, muito provavelmente, existe toda uma aplica√ß√£o com um motor de busca baseada rodando em algum servidor e a aplica√ß√£o que est√° rodando no lado do cliente faz uma requisi√ß√£o para essa aplica√ß√£o com o termo digitado que, por sua vez, responde com algumas sugest√µes a serem exibidas.

No entanto, se essa a√ß√£o fosse disparada a cada letra que digitamos na barra de busca, poder√≠amos ter uma sequ√™ncia de requisi√ß√µes sendo feitas de forma desnecess√°ria.

Vamos imaginar que assim que uma letra √© digitada no campo de busca essa a√ß√£o ocorra:
- Se voc√™ digitar `ps5` essa a√ß√£o ser√° feita 3 vezes;
- Se voc√™ digita (`jogos de ps5`) essa a√ß√£o ser√° feita 12 vezes.

Como nossa a√ß√£o est√° sendo disparada a cada letra digitada, a requisi√ß√£o ao servidor ser√° realizada a mesma quantidade de vezes que o usu√°rio teclar na barra de busca.

Al√©m de sobrecarregar nosso servi√ßo com chamadas desnecessariamente, a aplica√ß√£o que roda no navegador provavelmente ir√° atualizar v√°rias vezes tamb√©m com alguns resultados de busca que n√£o s√£o interessantes para o usu√°rio. Ambas as aplica√ß√µes est√£o tendo seu desempenho prejudicado desnecessariamente.

Al√©m disso, se voc√™ est√° pesquisando por `ps5` √© prov√°vel que s√≥ queira ver produtos relacionado a esse termo, e n√£o produtos relacionados √† um termo `p` ou `ps` (enquanto digita), n√£o acha?

Essa a√ß√£o poderia ser adiada usando `debounce` ou `throttle` para que essa pesquisa s√≥ fosse feita ap√≥s um certo per√≠odo de tempo em que o campo de busca foi preenchido, o que √© bem melhor pra todo mundo, pra experi√™ncia de quem est√° comprando e para as duas aplica√ß√µes (no cliente e no servidor)!

### Como funcionam essas t√©cnicas?

Ambas as t√©cnicas funcionam de maneira parecida e isso √© bem confuso de entender, mas vamos pensar em um cen√°rio mais interessante: voc√™ √© uma crian√ßa e est√° viajando com seus pais, voc√™s est√£o indo de carro passar as f√©rias üèù em algum lugar (deixe sua imagina√ß√£o fluir aqui).

Como toda crian√ßa, voc√™ n√£o gosta de ficar esperando e est√° super ansiosa pra chegar no destino e de 5 em 5 minutos voc√™ faz aquela pergunta que todo mundo j√° vez na vida: "tamo chegando?".

A cada vez que voc√™ pergunta, seus pais muito provavelmente v√£o responder "sim" ou "n√£o" <del>e talvez ignorar voc√™ depois de um tempo</del>.

Inevitavelmente voc√™s v√£o chegar no destino e ficar perguntando n√£o vai mudar muita coisa, certo?

Se "chegar no destino" fosse uma a√ß√£o, nesse momento, ela estaria sofrendo `throttle`. N√£o importa quantas vezes voc√™ pergunte, ela s√≥ ser√° realizada quando o trajeto da viagem for conclu√≠do e perguntar n√£o vai fazer voc√™ chegar mais r√°pido.

Utilizando `throttling`, n√£o importa quantas vezes voc√™ tente realizar uma a√ß√£o, ela s√≥ ser√° realizada ao final de um determinado tempo.

Agora vamos pensar em um outro cen√°rio, onde seus pais querem zoar voc√™ e, a cada vez que voc√™ pergunta se est√° chegando, eles d√£o uma volta a mais em alguma quadra. Por fim, voc√™s n√£o v√£o chegar no destino at√© que voc√™ pare de perguntar. Nesse caso, essa a√ß√£o estaria sofrendo `debounce`. Dessa vez, perguntar faz com que a chegada ao destino fique cada vez mais atrasada.

Utilizando `debounce`, a cada vez que voc√™ tenta realizar uma a√ß√£o, ela ser√° adiada por mais um tempo, at√© que n√£o haja mais tentativa e ela seja, por fim, executada.

O [post no site Telerik, escrito por Rupesh Mishra](https://www.telerik.com/blogs/debouncing-and-throttling-in-javascript) tamb√©m tem uma √≥tima analogia com bolo que pode complementar.

### Um pequeno exemplo com c√≥digo

#### Criando nossa a√ß√£o principal
Vamos voltar ao nosso primeiro exemplo do e-commerce com nossa barra de busca. Vamos imaginar que nossa simplesmente exibe um `log` na tela como:
```js
const acao = () => {
  console.log('a√ß√£o realizada, pesquisando...');
};
```

Como sabemos que iremos trabalhar para adiar essa a√ß√£o, vamos criar uma vari√°vel de `tempo`. Iremos adiar sua execu√ß√£o em 3 segundos, portanto, `3000` milissegundos:
```js
const acao = () => {
  console.log('a√ß√£o realizada, pesquisando...');
};
const tempo = 3000;
```

#### Criando nossas fun√ß√µes "atrasadoras"
J√° sabemos que vamos trabalhar com `debounce` e `throttle`. Para trabalhar com tempo e adiar alguma execu√ß√£o utilizaremos o `setTimeout`.

Para deixar as coisas mais informais, vamos chamar essas fun√ß√µes de "atrasadoras", tudo bem?

##### Debounce
No caso do `debounce` precisamos receber uma a√ß√£o e um determinado tempo como par√¢metro e, como essa a√ß√£o dever√° ficar se repetindo, retornaremos uma nova fun√ß√£o:
```js
const debounce = (fn, tempo) => {
  return () => {
  };
};
```

Precisamos ter uma maneira de controlar esse comportamento onde, a cada vez que a fun√ß√£o de retorno √© chamada, seu tempo √© reiniciado e ela s√≥ ser√° executada uma √∫nica vez ao final de todas as tentativas. Vamos criar uma vari√°vel `debounced` que ser√° usada para isso:
```js
const debounce = (fn, tempo) => {
  let debounced;

  return () => {
  };
};
```

Iremos executar a fun√ß√£o `setTimeout` passando como argumento nosso par√¢metros `fn` e `tempo`. Essa nova vari√°vel `debounced` ir√° armazenar o retorno do temporizador que a fun√ß√£o `setTimeout` retorna:
```js
const debounce = (fn, tempo) => {
  let debounced;

  return () => {
    debounced = setTimeout(fn, tempo);
  };
};
```

Agora, n√£o podemos esquecer de limpar nosso temporizador a cada vez que uma tentativa de executar a a√ß√£o `fn` √© realizada (simulando aquela volta extra na quadra a cada vez que voc√™ perguntava "estamos chegando?"). Podemos fazer isso com a fun√ß√£o `clearTimeout`:
```js
const debounce = (fn, tempo) => {
  let debounced;

  return () => {
    clearTimeout(debounced);
    debounced = setTimeout(fn, tempo);
  };
};
```

##### Throttle
J√° essa fun√ß√£o ser√° ainda mais simples.

Como agora a a√ß√£o ser√° realizada independente de quantas vezes √© chamada, s√≥ precisaremos usar nosso `setTimeout`.
```js
const throttle = (fn, tempo) => {
  setTimeout(fn, tempo);
};
```

Vamos manter o retorno de uma fun√ß√£o para que possamos continuar com a "tentativa" de cham√°-la (como se fosse a constante pergunta "estamos chegando"):
```js
const throttle = (fn, tempo) => {
  setTimeout(fn, tempo);

  return () => {
    // n√£o precisamos fazer nada
    // mas vamos retornar uma fun√ß√£o pra manter
    // o mesmo racioc√≠nio do nosso outro exemplo
  };
};
```

#### Juntando tudo e perguntando "j√° chegamos?" diversas vezes
Podemos criar mais duas fun√ß√µes e adicionar alguns logs extras, apenas pra deixar nosso exemplo mais claro.

Podemos at√© colocar mais um `setTimeout` para mostrar a diferen√ßa do `debounce` e do `throttle`.

Vamos criar uma fun√ß√£o `executaAcaoComDebounce` que ir√° tentar executar a nossa acao "atrasada" diversas vezes.
```js
const executaAcaoComDebounce = () => {
  // um log qualquer de in√≠cio
  console.log('iniciando execu√ß√£o com debounce');

  // criamos nossa fun√ß√£o baseada na a√ß√£o principal com debounce
  const debounced = debounce(acao, tempo);

  // tentamos executar a fun√ß√£o varias vezes
  debounced();
  debounced();
  debounced();
  setTimeout(() => {
    // tentamos executar ap√≥s o tempo de 2 segundos (3 segundos - 1 segundo)
    console.log('timeout tentando chamar a fun√ß√£o debounced')
    debounced();
  }, tempo - 1000);
};
```

Agora vamos fazer o mesmo exemplo, mas chamado `executaAcaoComThrottle`, fazendo as devidas modifica√ß√µes:
```js
const executaAcaoComThrottling = () => {
  // um log qualquer de in√≠cio
  console.log('iniciando execu√ß√£o com throttling');

  // criamos nossa fun√ß√£o baseada na a√ß√£o principal com throttle
  const throttled = throttle(acao, tempo);

  // tentamos executar a fun√ß√£o varias vezes
  throttled();
  throttled();
  throttled();
  setTimeout(() => {
      // tentamos executar ap√≥s o tempo de 2 segundos (3 segundos - 1 segundo)
      console.log('timeout tentando chamar a fun√ß√£o throttled');
      throttled();
  }, tempo - 1000);
};
```

Agora, basta executar qualquer uma dessas duas fun√ß√µes e ver o resultado!

Se voc√™ notar, como o `debounce` atrasa a execu√ß√£o da a√ß√£o, ele s√≥ ser√° executado 3 segundos ap√≥s **todas** as tentativas terminarem. J√° a vers√£o com `throttle`, ser√° executada ap√≥s 3 segundos, independente de quantas vezes tentamos e √© justamente por isso que nossa mensagem `a√ß√£o realizada, pesquisando...` aparecer√° antes/depois dependendo do exemplo que voc√™ estiver executando.

#### C√≥digo completo
Para facilitar, o c√≥digo completo √© esse aqui:
```js
// A√ß√£o principal
const acao = () => {
  console.log('a√ß√£o realizada, pesquisando...');
};
const tempo = 3000;

// Fun√ß√µes atrasadoras
const debounce = (fn, tempo) => {
  let debounced;

  return () => {
    clearTimeout(debounced);
    debounced = setTimeout(fn, tempo);
  };
};
const throttle = (fn, tempo) => {
  setTimeout(fn, tempo);

  return () => {};
};

// A√ß√µes com tentativas
const executaAcaoComDebounce = () => {
  console.log('iniciando execu√ß√£o com debounce');

  const debounced = debounce(acao, tempo);

  debounced();
  debounced();
  debounced();
  setTimeout(() => {
    console.log('timeout tentando chamar a fun√ß√£o debounced')
    debounced();
  }, tempo - 1000);
};

const executaAcaoComThrottling = () => {
  console.log('iniciando execu√ß√£o com throttling');

  const throttled = throttle(acao, tempo);

  throttled();
  throttled();
  throttled();
  setTimeout(() => {
      console.log('timeout tentando chamar a fun√ß√£o throttled');
      throttled();
  }, tempo - 1000);
};
```
